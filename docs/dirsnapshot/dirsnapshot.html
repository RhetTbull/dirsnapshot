<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dirsnapshot.dirsnapshot API documentation</title>
<meta name="description" content="Report differences between a directory and a previous snapshot of the same directory â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dirsnapshot.dirsnapshot</code></h1>
</header>
<section id="section-intro">
<p>Report differences between a directory and a previous snapshot of the same directory. </p>
<p>This works very similar to <a href="https://docs.python.org/3/library/filecmp.html#the-dircmp-class">dircmp</a>
but it is designed to be used with a directory that is being monitored instead of comparing two
existing directories.</p>
<p>This module can be run as a standalone CLI app or included in your project as a module.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Report differences between a directory and a previous snapshot of the same directory. 

This works very similar to [dircmp](https://docs.python.org/3/library/filecmp.html#the-dircmp-class) 
but it is designed to be used with a directory that is being monitored instead of comparing two 
existing directories.

This module can be run as a standalone CLI app or included in your project as a module.
&#34;&#34;&#34;

import dataclasses
import datetime
import json
import os
import sqlite3
from collections import namedtuple
from dataclasses import dataclass
from os import stat as osstat
from os import walk as oswalk
from os.path import exists as pathexists
from os.path import join as joinpath
from typing import Any, Callable, Dict, Iterator, List, Optional, Tuple, Union

from ._version import __version__

# Note: os.stat, os.walk, os.path.exists, os.path.join are imported as separate names
# because this increases performance slightly and these will be called repeatedly to
# create the snapshot


__all__ = [
    &#34;create_snapshot_in_memory&#34;,
    &#34;create_snapshot&#34;,
    &#34;DirDiff&#34;,
    &#34;DirDiffResults&#34;,
    &#34;DirSnapshot&#34; &#34;is_snapshot_file&#34;,
    &#34;load_snapshot&#34;,
    &#34;SnapshotInfo&#34;,
    &#34;SnapshotRecord&#34;,
]

METADATA_SOURCE = &#34;https://github.com/RhetTbull/dirsnapshot&#34;
METADATA_DESCRIPTION = &#34;Directory Snapshot created by dirsnapshot&#34;


&#34;&#34;&#34;Info about a snapshot returned by DirSnapshot.info&#34;&#34;&#34;
SnapshotInfo = namedtuple(&#34;SnapshotInfo&#34;, [&#34;description&#34;, &#34;directory&#34;, &#34;datetime&#34;])


def create_snapshot(
    dirpath: str,
    snapshot_db: str,
    walk: bool = True,
    description: Optional[str] = None,
    filter_function: Optional[Callable[[str], bool]] = None,
) -&gt; &#34;DirSnapshot&#34;:
    &#34;&#34;&#34;Factory function to create a snapshot of a directory

    Args:
        dir: path to directory to snapshot
        snapshot_db: path to database to write snapshot to
        walk: if True, walk the directory tree and add all files and directories
        description: optional description of the snapshot
        filter: optional function to filter out files and directories; should return True if the file or directory should be included in the snapshot

    Returns:
        DirSnapshot object

    Raises:
        ValueError if snapshot_db already exists
    &#34;&#34;&#34;

    if snapshot_db != &#34;:memory:&#34; and pathexists(snapshot_db):
        raise ValueError(f&#34;Snapshot database {snapshot_db} already exists&#34;)

    snapshot = DirSnapshot()
    snapshot.init_from_dir(dirpath, snapshot_db, walk, description, filter_function)
    return snapshot


def create_snapshot_in_memory(
    dirpath: str,
    walk: bool = True,
    description: Optional[str] = None,
    filter_function: Optional[Callable[[str], bool]] = None,
) -&gt; &#34;DirSnapshot&#34;:
    &#34;&#34;&#34;Factory function to create a snapshot of a directory in memory

    Args:
        dir: path to directory to snapshot
        walk: if True, walk the directory tree and add all files and directories
        description: optional description of the snapshot

    Returns:
        DirSnapshot object
    &#34;&#34;&#34;
    return create_snapshot(dirpath, &#34;:memory:&#34;, walk, description, filter_function)


def load_snapshot(snapshot_db: str) -&gt; &#34;DirSnapshot&#34;:
    &#34;&#34;&#34;Factory function to load a snapshot from a database file

    Args:
        snapshot_db: path to database file

    Returns:
        DirSnapshot object
    &#34;&#34;&#34;
    snapshot = DirSnapshot()
    snapshot.load_from_snapshot_db(snapshot_db)
    return snapshot


def is_snapshot_file(pathstr: str) -&gt; bool:
    &#34;&#34;&#34;Return True if the given path is a snapshot database file, otherwise False&#34;&#34;&#34;
    pathstr = os.path.abspath(os.path.expanduser(pathstr))
    try:
        conn = sqlite3.connect(f&#34;file:{pathstr}?mode=ro&#34;, uri=True)
        cursor = conn.cursor()
        return (
            cursor.execute(
                &#34;&#34;&#34;
        SELECT count(*)
        FROM sqlite_master
        WHERE type=&#39;table&#39;
        AND name=&#39;snapshot&#39;;
        &#34;&#34;&#34;
            ).fetchone()[0]
            == 1
        )
    except Exception as e:
        return False


@dataclass
class SnapshotRecord:
    &#34;&#34;&#34;Snapshot details for a file or directory.

    Attributes:
        path: path to file or directory
        is_dir: True if the path is a directory, False if it is a file
        is_file: True if the path is a file, False if it is a directory
        mode: file mode of file or directory
        uid: user ID of file or directory
        gid: group ID of file or directory
        size: size of file or directory in bytes
        mtime: modification time of file or directory
        user_data: optional user data associated with the file or directory
    &#34;&#34;&#34;

    path: str
    is_dir: bool
    is_file: bool
    mode: int
    uid: int
    gid: int
    size: int
    mtime: int
    user_data: Optional[Any] = None

    def asdict(self):
        return dataclasses.asdict(self)


class DirSnapshot:
    &#34;&#34;&#34;Create a snapshot of a directory for use with DirDiff&#34;&#34;&#34;

    def __init__(self):
        pass

    def init_from_dir(
        self,
        dirpath: str,
        snapshot_db: str,
        walk: bool = True,
        description: Optional[str] = None,
        filter_function: Optional[Callable[[str], bool]] = None,
    ):
        &#34;&#34;&#34;Create a snapshot from a directory

        Args:
            dirpath: path to the directory to snapshot
            snapshot_db: path to database to write snapshot to
            walk: if True, walk the directory tree and add all files and directories
            description: optional description of the snapshot
            filter: optional function to filter out files and directories; should return True if the file or directory should be included in the snapshot
        &#34;&#34;&#34;
        if pathexists(snapshot_db):
            raise ValueError(f&#34;Snapshot database {snapshot_db} already exists&#34;)
        if not os.path.isdir(dirpath):
            raise ValueError(
                f&#34;Directory {dirpath} does not exist or is not a directory&#34;
            )

        conn, cursor = self._create_snapshot_db(snapshot_db, dirpath, description)
        self.conn = conn
        self._snapshot(dirpath, walk, conn, cursor, filter_function)

    def load_from_snapshot_db(self, snapshot_db: str):
        &#34;&#34;&#34;Load a snapshot from a database file

        Args:
            snapshot_db: path to database file
        &#34;&#34;&#34;
        if not is_snapshot_file(snapshot_db):
            raise ValueError(f&#34;{snapshot_db} is not a snapshot database&#34;)
        conn, _ = self._open_snapshot_db(snapshot_db)
        self.conn = conn

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Return the description of the snapshot&#34;&#34;&#34;
        return self.info.description

    @property
    def directory(self) -&gt; str:
        &#34;&#34;&#34;Return the directory of the snapshot&#34;&#34;&#34;
        return self.info.directory

    @property
    def datetime(self) -&gt; datetime.datetime:
        &#34;&#34;&#34;Return the datetime of the snapshot&#34;&#34;&#34;
        return datetime.datetime.fromisoformat(self.info.datetime)

    @property
    def info(self) -&gt; SnapshotInfo:
        &#34;&#34;&#34;Return info about a snapshot as a named tuple.

        Returns:
            SnapshotInfo named tuple
        &#34;&#34;&#34;
        cursor = self.conn.cursor()
        cursor.execute(
            &#34;SELECT description, directory, datetime FROM about ORDER BY datetime DESC LIMIT 1&#34;
        )
        description, directory, dt = cursor.fetchone()
        return SnapshotInfo(description, directory, dt)

    def files(self) -&gt; Iterator[str]:
        &#34;&#34;&#34;Generator to return all files in the snapshot&#34;&#34;&#34;
        cursor = self.conn.cursor()
        cursor.execute(&#34;SELECT path FROM snapshot&#34;)
        for row in cursor:
            yield row[0]

    def record(self, filepath: str) -&gt; Optional[SnapshotRecord]:
        &#34;&#34;&#34;Return the snapshot record for a filepath or None if the filepath is not in the snapshot&#34;&#34;&#34;
        cursor = self.conn.cursor()
        cursor.execute(
            &#34;SELECT path, is_dir, is_file, st_mode, st_uid, st_gid, st_size, st_mtime, user_data FROM snapshot WHERE path = ?&#34;,
            (filepath,),
        )
        results = cursor.fetchone()
        if results is None:
            return None
        return SnapshotRecord(*results)

    def records(self) -&gt; Iterator[SnapshotRecord]:
        &#34;&#34;&#34;Generator to return all files in the snapshot&#34;&#34;&#34;
        cursor = self.conn.cursor()
        cursor.execute(
            &#34;SELECT path, is_dir, is_file, st_mode, st_uid, st_gid, st_size, st_mtime FROM snapshot&#34;
        )
        for row in cursor:
            yield SnapshotRecord(*row)

    def _create_snapshot_db(
        self,
        dbpath: str,
        dirpath: Optional[str] = None,
        description: Optional[str] = None,
    ) -&gt; Tuple[sqlite3.Connection, sqlite3.Cursor]:
        &#34;&#34;&#34;Initialize a snapshot db, and return a connection and cursor

        Args:
            dbpath: path to database to open
            dirpath: path to the directory to snapshot
            description: optional description of the snapshot

        Returns:
            sqlite3.Connection, sqlite3.Cursor
        &#34;&#34;&#34;

        conn = sqlite3.connect(dbpath)
        cursor = conn.cursor()

        cursor.execute(
            &#34;&#34;&#34;
            CREATE TABLE IF NOT EXISTS snapshot (
                path TEXT, 
                is_dir INTEGER,
                is_file INTEGER,
                st_mode INTEGER, 
                st_uid INTEGER, 
                st_gid INTEGER, 
                st_size INTEGER, 
                st_mtime INTEGER,
                user_data BLOB
                );
        &#34;&#34;&#34;
        )

        cursor.execute(
            &#34;&#34;&#34;
            CREATE TABLE IF NOT EXISTS _metadata (
                description TEXT, source TEXT, version TEXT, created_at DATETIME);
        &#34;&#34;&#34;
        )

        cursor.execute(
            &#34;&#34;&#34;
            CREATE TABLE IF NOT EXISTS about (
                description TEXT, directory TEXT, datetime DATETIME);
        &#34;&#34;&#34;
        )

        cursor.execute(
            &#34;&#34;&#34;
            CREATE INDEX IF NOT EXISTS snapshot_path_index ON snapshot (path);
            &#34;&#34;&#34;
        )

        now = datetime.datetime.now().isoformat()
        description = description or f&#34;Snapshot created at {now}&#34;
        dirpath = dirpath or &#34;&#34;
        cursor.execute(
            &#34;INSERT INTO about VALUES (?, ?, ?)&#34;, (description, dirpath, now)
        )
        cursor.execute(
            &#34;INSERT INTO _metadata VALUES (?, ?, ?, ?)&#34;,
            (METADATA_DESCRIPTION, METADATA_SOURCE, __version__, now),
        )
        conn.commit()
        return conn, cursor

    def _open_snapshot_db(
        self, dbpath: str
    ) -&gt; Tuple[sqlite3.Connection, sqlite3.Cursor]:
        &#34;&#34;&#34;Open a snapshot db, and return a connection and cursor

        Args:
            dbpath: path to database to open

        Returns:
            sqlite3.Connection, sqlite3.Cursor
        &#34;&#34;&#34;
        conn = sqlite3.connect(dbpath)
        cursor = conn.cursor()
        return conn, cursor

    def _add_snapshot_db_entry(
        self,
        cursor: sqlite3.Cursor,
        pathstr: str,
        statinfo: os.stat_result,
        is_dir: bool,
        is_file: bool,
    ):
        cursor.execute(
            &#34;&#34;&#34;INSERT INTO snapshot VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)&#34;&#34;&#34;,
            (
                pathstr,
                1 if is_dir else 0,
                1 if is_file else 0,
                statinfo.st_mode,
                statinfo.st_uid,
                statinfo.st_gid,
                statinfo.st_size,
                statinfo.st_mtime,
                b&#34;&#34;,
            ),
        )

    def _snapshot(
        self,
        dirpath: str,
        walk: bool,
        conn: sqlite3.Connection,
        cursor: sqlite3.Cursor,
        filter_function: Callable[[str], bool] = None,
    ):
        for current_dirpath, dirnames, filenames in oswalk(dirpath):
            for dirname in dirnames:
                pathstr = joinpath(current_dirpath, dirname)
                if filter_function and not filter_function(pathstr):
                    continue
                statinfo = osstat(pathstr)
                self._add_snapshot_db_entry(
                    cursor, pathstr, statinfo, is_dir=True, is_file=False
                )

            for filename in filenames:
                pathstr = joinpath(current_dirpath, filename)
                if filter_function and not filter_function(pathstr):
                    continue
                statinfo = osstat(pathstr)
                self._add_snapshot_db_entry(
                    cursor, pathstr, statinfo, is_dir=False, is_file=True
                )
            if not walk:
                # don&#39;t continue walking the the tree
                break

        conn.commit()


@dataclass
class DirDiffResults:
    &#34;&#34;&#34;Results of a directory comparison as returned by DirDiff.diff()&#34;&#34;&#34;

    added: List[str]
    removed: List[str]
    modified: List[str]
    identical: List[str]

    def asdict(self):
        return dataclasses.asdict(self)

    def json(self):
        return json.dumps(self.asdict())


class DirDiff:
    def __init__(
        self,
        snapshot_a: Union[str, DirSnapshot],
        directory_or_snapshot_b: Union[str, DirSnapshot],
        walk: bool = True,
        filter_function: Optional[Callable[[str], bool]] = None,
    ):
        &#34;&#34;&#34;Initialize the DirDiff instance

        Args:
            snapshot_a: path to previous snapshot database to compare or a DirSnapshot instance
            directory_or_snapshot_b: path to current snapshot database, DirSnapshot instance, or path to directory to compare snapshot_a to
            walk: if True, walks the directory tree and recursively adds all files and directories
        &#34;&#34;&#34;

        if isinstance(snapshot_a, str):
            self.snapshot_a = load_snapshot(snapshot_a)
        elif isinstance(snapshot_a, DirSnapshot):
            self.snapshot_a = snapshot_a
        else:
            raise ValueError(
                f&#34;{snapshot_a} is not a snapshot database or DirSnapshot instance&#34;
            )

        if isinstance(directory_or_snapshot_b, DirSnapshot):
            self.snapshot_b = directory_or_snapshot_b
        elif os.path.isdir(directory_or_snapshot_b):
            self.snapshot_b = create_snapshot_in_memory(directory_or_snapshot_b, walk)
        elif is_snapshot_file(directory_or_snapshot_b):
            self.snapshot_b = load_snapshot(directory_or_snapshot_b)
        else:
            raise ValueError(
                f&#34;{directory_or_snapshot_b} is not a directory or a snapshot database&#34;
            )

        self._diff: Optional[DirDiffResults] = None
        self.walk = walk
        self.filter_function = filter_function

    def diff(
        self,
        compare_function: Optional[
            Callable[[SnapshotRecord, SnapshotRecord], bool]
        ] = None,
    ) -&gt; DirDiffResults:
        &#34;&#34;&#34;Compare the current directory or snapshot to the previous snapshot

        Args:
            `compare_function`: optional function to filter the results, receives a pair of SnapshotRecords and returns True if the pair are equal, otherwise False

        Returns:
            diff results as DirDiffResults instance
        &#34;&#34;&#34;
        self._diff = self._diff_snapshots(compare_function)
        return self._diff

    def report(self, include_identical=False) -&gt; None:
        &#34;&#34;&#34;Print a report of the diff to stdout.

        Args:
            include_identical: if True, print files that are identical
        &#34;&#34;&#34;

        diff = self.diff()

        info_a = self.snapshot_a.info
        info_b = self.snapshot_b.info
        print(
            f&#34;diff &#39;{info_a.directory}&#39; {info_a.datetime} ({info_a.description}) vs {info_b.datetime} ({info_b.description})&#34;
        )
        print(&#34;Added: &#34;)
        print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.added]))
        if diff.added:
            print()
        print(&#34;Removed: &#34;)
        print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.removed]))
        if diff.removed:
            print()
        print(&#34;Modified: &#34;)
        print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.modified]))
        if diff.modified and include_identical:
            print()
        if include_identical:
            print(&#34;Identical: &#34;)
            print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.identical]))

    def compare_records(
        self, record_a: SnapshotRecord, record_b: SnapshotRecord
    ) -&gt; bool:
        &#34;&#34;&#34;The default compare function for DirDiff.diff();
        override this in your subclass to implement custom compare, or use compare_function arg to diff

        Args:
            record_a: first SnapshotRecord to compare
            record_b: second SnapshotRecord to compare

        Returns:
            True if the records are equal, otherwise False
        &#34;&#34;&#34;
        return (
            record_a.is_dir == record_b.is_dir
            and record_a.is_file == record_b.is_file
            and record_a.mode == record_b.mode
            and record_a.uid == record_b.uid
            and record_a.gid == record_b.gid
            and record_a.size == record_b.size
            and record_a.mtime == record_b.mtime
        )

    def _diff_snapshots(
        self,
        compare_function: Optional[
            Callable[[SnapshotRecord, SnapshotRecord], bool]
        ] = None,
    ) -&gt; DirDiffResults:
        &#34;&#34;&#34;Diff two database snapshots

        Returns:
            DirDiffResults instance
        &#34;&#34;&#34;
        diffresults: Dict = {
            &#34;added&#34;: [],
            &#34;removed&#34;: [],
            &#34;modified&#34;: [],
            &#34;identical&#34;: [],
        }

        compare_function = compare_function or self.compare_records

        paths_b = {}
        for row_b in self.snapshot_b.records():
            if self.filter_function and not self.filter_function(row_b.path):
                continue
            paths_b[row_b.path] = 1
            if row_a := self.snapshot_a.record(row_b.path):
                if not compare_function(row_a, row_b):
                    diffresults[&#34;modified&#34;].append(row_b.path)
                else:
                    diffresults[&#34;identical&#34;].append(row_b.path)
            else:
                diffresults[&#34;added&#34;].append(row_b.path)
        for row_a in self.snapshot_a.records():
            if self.filter_function and not self.filter_function(row_a.path):
                continue
            if row_a.path not in paths_b:
                diffresults[&#34;removed&#34;].append(row_a.path)

        return DirDiffResults(**diffresults)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dirsnapshot.dirsnapshot.create_snapshot"><code class="name flex">
<span>def <span class="ident">create_snapshot</span></span>(<span>dirpath:Â str, snapshot_db:Â str, walk:Â boolÂ =Â True, description:Â Optional[str]Â =Â None, filter_function:Â Optional[Callable[[str],Â bool]]Â =Â None) â€‘>Â dirsnapshot.dirsnapshot.DirSnapshot</span>
</code></dt>
<dd>
<div class="desc"><p>Factory function to create a snapshot of a directory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dir</code></strong></dt>
<dd>path to directory to snapshot</dd>
<dt><strong><code>snapshot_db</code></strong></dt>
<dd>path to database to write snapshot to</dd>
<dt><strong><code>walk</code></strong></dt>
<dd>if True, walk the directory tree and add all files and directories</dd>
<dt><strong><code>description</code></strong></dt>
<dd>optional description of the snapshot</dd>
<dt><strong><code>filter</code></strong></dt>
<dd>optional function to filter out files and directories; should return True if the file or directory should be included in the snapshot</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DirSnapshot object</p>
<h2 id="raises">Raises</h2>
<p>ValueError if snapshot_db already exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_snapshot(
    dirpath: str,
    snapshot_db: str,
    walk: bool = True,
    description: Optional[str] = None,
    filter_function: Optional[Callable[[str], bool]] = None,
) -&gt; &#34;DirSnapshot&#34;:
    &#34;&#34;&#34;Factory function to create a snapshot of a directory

    Args:
        dir: path to directory to snapshot
        snapshot_db: path to database to write snapshot to
        walk: if True, walk the directory tree and add all files and directories
        description: optional description of the snapshot
        filter: optional function to filter out files and directories; should return True if the file or directory should be included in the snapshot

    Returns:
        DirSnapshot object

    Raises:
        ValueError if snapshot_db already exists
    &#34;&#34;&#34;

    if snapshot_db != &#34;:memory:&#34; and pathexists(snapshot_db):
        raise ValueError(f&#34;Snapshot database {snapshot_db} already exists&#34;)

    snapshot = DirSnapshot()
    snapshot.init_from_dir(dirpath, snapshot_db, walk, description, filter_function)
    return snapshot</code></pre>
</details>
</dd>
<dt id="dirsnapshot.dirsnapshot.create_snapshot_in_memory"><code class="name flex">
<span>def <span class="ident">create_snapshot_in_memory</span></span>(<span>dirpath:Â str, walk:Â boolÂ =Â True, description:Â Optional[str]Â =Â None, filter_function:Â Optional[Callable[[str],Â bool]]Â =Â None) â€‘>Â dirsnapshot.dirsnapshot.DirSnapshot</span>
</code></dt>
<dd>
<div class="desc"><p>Factory function to create a snapshot of a directory in memory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dir</code></strong></dt>
<dd>path to directory to snapshot</dd>
<dt><strong><code>walk</code></strong></dt>
<dd>if True, walk the directory tree and add all files and directories</dd>
<dt><strong><code>description</code></strong></dt>
<dd>optional description of the snapshot</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DirSnapshot object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_snapshot_in_memory(
    dirpath: str,
    walk: bool = True,
    description: Optional[str] = None,
    filter_function: Optional[Callable[[str], bool]] = None,
) -&gt; &#34;DirSnapshot&#34;:
    &#34;&#34;&#34;Factory function to create a snapshot of a directory in memory

    Args:
        dir: path to directory to snapshot
        walk: if True, walk the directory tree and add all files and directories
        description: optional description of the snapshot

    Returns:
        DirSnapshot object
    &#34;&#34;&#34;
    return create_snapshot(dirpath, &#34;:memory:&#34;, walk, description, filter_function)</code></pre>
</details>
</dd>
<dt id="dirsnapshot.dirsnapshot.load_snapshot"><code class="name flex">
<span>def <span class="ident">load_snapshot</span></span>(<span>snapshot_db:Â str) â€‘>Â dirsnapshot.dirsnapshot.DirSnapshot</span>
</code></dt>
<dd>
<div class="desc"><p>Factory function to load a snapshot from a database file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snapshot_db</code></strong></dt>
<dd>path to database file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DirSnapshot object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_snapshot(snapshot_db: str) -&gt; &#34;DirSnapshot&#34;:
    &#34;&#34;&#34;Factory function to load a snapshot from a database file

    Args:
        snapshot_db: path to database file

    Returns:
        DirSnapshot object
    &#34;&#34;&#34;
    snapshot = DirSnapshot()
    snapshot.load_from_snapshot_db(snapshot_db)
    return snapshot</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dirsnapshot.dirsnapshot.DirDiff"><code class="flex name class">
<span>class <span class="ident">DirDiff</span></span>
<span>(</span><span>snapshot_a:Â Union[str,Â dirsnapshot.dirsnapshot.DirSnapshot], directory_or_snapshot_b:Â Union[str,Â dirsnapshot.dirsnapshot.DirSnapshot], walk:Â boolÂ =Â True, filter_function:Â Optional[Callable[[str],Â bool]]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the DirDiff instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snapshot_a</code></strong></dt>
<dd>path to previous snapshot database to compare or a DirSnapshot instance</dd>
<dt><strong><code>directory_or_snapshot_b</code></strong></dt>
<dd>path to current snapshot database, DirSnapshot instance, or path to directory to compare snapshot_a to</dd>
<dt><strong><code>walk</code></strong></dt>
<dd>if True, walks the directory tree and recursively adds all files and directories</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirDiff:
    def __init__(
        self,
        snapshot_a: Union[str, DirSnapshot],
        directory_or_snapshot_b: Union[str, DirSnapshot],
        walk: bool = True,
        filter_function: Optional[Callable[[str], bool]] = None,
    ):
        &#34;&#34;&#34;Initialize the DirDiff instance

        Args:
            snapshot_a: path to previous snapshot database to compare or a DirSnapshot instance
            directory_or_snapshot_b: path to current snapshot database, DirSnapshot instance, or path to directory to compare snapshot_a to
            walk: if True, walks the directory tree and recursively adds all files and directories
        &#34;&#34;&#34;

        if isinstance(snapshot_a, str):
            self.snapshot_a = load_snapshot(snapshot_a)
        elif isinstance(snapshot_a, DirSnapshot):
            self.snapshot_a = snapshot_a
        else:
            raise ValueError(
                f&#34;{snapshot_a} is not a snapshot database or DirSnapshot instance&#34;
            )

        if isinstance(directory_or_snapshot_b, DirSnapshot):
            self.snapshot_b = directory_or_snapshot_b
        elif os.path.isdir(directory_or_snapshot_b):
            self.snapshot_b = create_snapshot_in_memory(directory_or_snapshot_b, walk)
        elif is_snapshot_file(directory_or_snapshot_b):
            self.snapshot_b = load_snapshot(directory_or_snapshot_b)
        else:
            raise ValueError(
                f&#34;{directory_or_snapshot_b} is not a directory or a snapshot database&#34;
            )

        self._diff: Optional[DirDiffResults] = None
        self.walk = walk
        self.filter_function = filter_function

    def diff(
        self,
        compare_function: Optional[
            Callable[[SnapshotRecord, SnapshotRecord], bool]
        ] = None,
    ) -&gt; DirDiffResults:
        &#34;&#34;&#34;Compare the current directory or snapshot to the previous snapshot

        Args:
            `compare_function`: optional function to filter the results, receives a pair of SnapshotRecords and returns True if the pair are equal, otherwise False

        Returns:
            diff results as DirDiffResults instance
        &#34;&#34;&#34;
        self._diff = self._diff_snapshots(compare_function)
        return self._diff

    def report(self, include_identical=False) -&gt; None:
        &#34;&#34;&#34;Print a report of the diff to stdout.

        Args:
            include_identical: if True, print files that are identical
        &#34;&#34;&#34;

        diff = self.diff()

        info_a = self.snapshot_a.info
        info_b = self.snapshot_b.info
        print(
            f&#34;diff &#39;{info_a.directory}&#39; {info_a.datetime} ({info_a.description}) vs {info_b.datetime} ({info_b.description})&#34;
        )
        print(&#34;Added: &#34;)
        print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.added]))
        if diff.added:
            print()
        print(&#34;Removed: &#34;)
        print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.removed]))
        if diff.removed:
            print()
        print(&#34;Modified: &#34;)
        print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.modified]))
        if diff.modified and include_identical:
            print()
        if include_identical:
            print(&#34;Identical: &#34;)
            print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.identical]))

    def compare_records(
        self, record_a: SnapshotRecord, record_b: SnapshotRecord
    ) -&gt; bool:
        &#34;&#34;&#34;The default compare function for DirDiff.diff();
        override this in your subclass to implement custom compare, or use compare_function arg to diff

        Args:
            record_a: first SnapshotRecord to compare
            record_b: second SnapshotRecord to compare

        Returns:
            True if the records are equal, otherwise False
        &#34;&#34;&#34;
        return (
            record_a.is_dir == record_b.is_dir
            and record_a.is_file == record_b.is_file
            and record_a.mode == record_b.mode
            and record_a.uid == record_b.uid
            and record_a.gid == record_b.gid
            and record_a.size == record_b.size
            and record_a.mtime == record_b.mtime
        )

    def _diff_snapshots(
        self,
        compare_function: Optional[
            Callable[[SnapshotRecord, SnapshotRecord], bool]
        ] = None,
    ) -&gt; DirDiffResults:
        &#34;&#34;&#34;Diff two database snapshots

        Returns:
            DirDiffResults instance
        &#34;&#34;&#34;
        diffresults: Dict = {
            &#34;added&#34;: [],
            &#34;removed&#34;: [],
            &#34;modified&#34;: [],
            &#34;identical&#34;: [],
        }

        compare_function = compare_function or self.compare_records

        paths_b = {}
        for row_b in self.snapshot_b.records():
            if self.filter_function and not self.filter_function(row_b.path):
                continue
            paths_b[row_b.path] = 1
            if row_a := self.snapshot_a.record(row_b.path):
                if not compare_function(row_a, row_b):
                    diffresults[&#34;modified&#34;].append(row_b.path)
                else:
                    diffresults[&#34;identical&#34;].append(row_b.path)
            else:
                diffresults[&#34;added&#34;].append(row_b.path)
        for row_a in self.snapshot_a.records():
            if self.filter_function and not self.filter_function(row_a.path):
                continue
            if row_a.path not in paths_b:
                diffresults[&#34;removed&#34;].append(row_a.path)

        return DirDiffResults(**diffresults)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dirsnapshot.dirsnapshot.DirDiff.compare_records"><code class="name flex">
<span>def <span class="ident">compare_records</span></span>(<span>self, record_a:Â <a title="dirsnapshot.dirsnapshot.SnapshotRecord" href="#dirsnapshot.dirsnapshot.SnapshotRecord">SnapshotRecord</a>, record_b:Â <a title="dirsnapshot.dirsnapshot.SnapshotRecord" href="#dirsnapshot.dirsnapshot.SnapshotRecord">SnapshotRecord</a>) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>The default compare function for DirDiff.diff();
override this in your subclass to implement custom compare, or use compare_function arg to diff</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>record_a</code></strong></dt>
<dd>first SnapshotRecord to compare</dd>
<dt><strong><code>record_b</code></strong></dt>
<dd>second SnapshotRecord to compare</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the records are equal, otherwise False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_records(
    self, record_a: SnapshotRecord, record_b: SnapshotRecord
) -&gt; bool:
    &#34;&#34;&#34;The default compare function for DirDiff.diff();
    override this in your subclass to implement custom compare, or use compare_function arg to diff

    Args:
        record_a: first SnapshotRecord to compare
        record_b: second SnapshotRecord to compare

    Returns:
        True if the records are equal, otherwise False
    &#34;&#34;&#34;
    return (
        record_a.is_dir == record_b.is_dir
        and record_a.is_file == record_b.is_file
        and record_a.mode == record_b.mode
        and record_a.uid == record_b.uid
        and record_a.gid == record_b.gid
        and record_a.size == record_b.size
        and record_a.mtime == record_b.mtime
    )</code></pre>
</details>
</dd>
<dt id="dirsnapshot.dirsnapshot.DirDiff.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>self, compare_function:Â Optional[Callable[[<a title="dirsnapshot.dirsnapshot.SnapshotRecord" href="#dirsnapshot.dirsnapshot.SnapshotRecord">SnapshotRecord</a>,Â <a title="dirsnapshot.dirsnapshot.SnapshotRecord" href="#dirsnapshot.dirsnapshot.SnapshotRecord">SnapshotRecord</a>],Â bool]]Â =Â None) â€‘>Â <a title="dirsnapshot.dirsnapshot.DirDiffResults" href="#dirsnapshot.dirsnapshot.DirDiffResults">DirDiffResults</a></span>
</code></dt>
<dd>
<div class="desc"><p>Compare the current directory or snapshot to the previous snapshot</p>
<h2 id="args">Args</h2>
<p><code>compare_function</code>: optional function to filter the results, receives a pair of SnapshotRecords and returns True if the pair are equal, otherwise False</p>
<h2 id="returns">Returns</h2>
<p>diff results as DirDiffResults instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(
    self,
    compare_function: Optional[
        Callable[[SnapshotRecord, SnapshotRecord], bool]
    ] = None,
) -&gt; DirDiffResults:
    &#34;&#34;&#34;Compare the current directory or snapshot to the previous snapshot

    Args:
        `compare_function`: optional function to filter the results, receives a pair of SnapshotRecords and returns True if the pair are equal, otherwise False

    Returns:
        diff results as DirDiffResults instance
    &#34;&#34;&#34;
    self._diff = self._diff_snapshots(compare_function)
    return self._diff</code></pre>
</details>
</dd>
<dt id="dirsnapshot.dirsnapshot.DirDiff.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self, include_identical=False) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Print a report of the diff to stdout.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>include_identical</code></strong></dt>
<dd>if True, print files that are identical</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report(self, include_identical=False) -&gt; None:
    &#34;&#34;&#34;Print a report of the diff to stdout.

    Args:
        include_identical: if True, print files that are identical
    &#34;&#34;&#34;

    diff = self.diff()

    info_a = self.snapshot_a.info
    info_b = self.snapshot_b.info
    print(
        f&#34;diff &#39;{info_a.directory}&#39; {info_a.datetime} ({info_a.description}) vs {info_b.datetime} ({info_b.description})&#34;
    )
    print(&#34;Added: &#34;)
    print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.added]))
    if diff.added:
        print()
    print(&#34;Removed: &#34;)
    print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.removed]))
    if diff.removed:
        print()
    print(&#34;Modified: &#34;)
    print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.modified]))
    if diff.modified and include_identical:
        print()
    if include_identical:
        print(&#34;Identical: &#34;)
        print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.identical]))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults"><code class="flex name class">
<span>class <span class="ident">DirDiffResults</span></span>
<span>(</span><span>added:Â List[str], removed:Â List[str], modified:Â List[str], identical:Â List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Results of a directory comparison as returned by DirDiff.diff()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class DirDiffResults:
    &#34;&#34;&#34;Results of a directory comparison as returned by DirDiff.diff()&#34;&#34;&#34;

    added: List[str]
    removed: List[str]
    modified: List[str]
    identical: List[str]

    def asdict(self):
        return dataclasses.asdict(self)

    def json(self):
        return json.dumps(self.asdict())</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults.added"><code class="name">var <span class="ident">added</span> :Â List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults.identical"><code class="name">var <span class="ident">identical</span> :Â List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults.modified"><code class="name">var <span class="ident">modified</span> :Â List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults.removed"><code class="name">var <span class="ident">removed</span> :Â List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults.asdict"><code class="name flex">
<span>def <span class="ident">asdict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asdict(self):
    return dataclasses.asdict(self)</code></pre>
</details>
</dd>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self):
    return json.dumps(self.asdict())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults"><code class="flex name class">
<span>class <span class="ident">DirSnapshotis_snapshot_file</span></span>
<span>(</span><span>added:Â List[str], removed:Â List[str], modified:Â List[str], identical:Â List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Results of a directory comparison as returned by DirDiff.diff()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class DirDiffResults:
    &#34;&#34;&#34;Results of a directory comparison as returned by DirDiff.diff()&#34;&#34;&#34;

    added: List[str]
    removed: List[str]
    modified: List[str]
    identical: List[str]

    def asdict(self):
        return dataclasses.asdict(self)

    def json(self):
        return json.dumps(self.asdict())</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults.added"><code class="name">var <span class="ident">added</span> :Â List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults.identical"><code class="name">var <span class="ident">identical</span> :Â List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults.modified"><code class="name">var <span class="ident">modified</span> :Â List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults.removed"><code class="name">var <span class="ident">removed</span> :Â List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults.asdict"><code class="name flex">
<span>def <span class="ident">asdict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asdict(self):
    return dataclasses.asdict(self)</code></pre>
</details>
</dd>
<dt id="dirsnapshot.dirsnapshot.DirDiffResults.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self):
    return json.dumps(self.asdict())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dirsnapshot.dirsnapshot.SnapshotInfo"><code class="flex name class">
<span>class <span class="ident">SnapshotInfo</span></span>
<span>(</span><span>description, directory, datetime)</span>
</code></dt>
<dd>
<div class="desc"><p>SnapshotInfo(description, directory, datetime)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="dirsnapshot.dirsnapshot.SnapshotInfo.datetime"><code class="name">var <span class="ident">datetime</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.SnapshotInfo.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.SnapshotInfo.directory"><code class="name">var <span class="ident">directory</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="dirsnapshot.dirsnapshot.SnapshotRecord"><code class="flex name class">
<span>class <span class="ident">SnapshotRecord</span></span>
<span>(</span><span>path:Â str, is_dir:Â bool, is_file:Â bool, mode:Â int, uid:Â int, gid:Â int, size:Â int, mtime:Â int, user_data:Â Optional[Any]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Snapshot details for a file or directory.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>path to file or directory</dd>
<dt><strong><code>is_dir</code></strong></dt>
<dd>True if the path is a directory, False if it is a file</dd>
<dt><strong><code>is_file</code></strong></dt>
<dd>True if the path is a file, False if it is a directory</dd>
<dt><strong><code>mode</code></strong></dt>
<dd>file mode of file or directory</dd>
<dt><strong><code>uid</code></strong></dt>
<dd>user ID of file or directory</dd>
<dt><strong><code>gid</code></strong></dt>
<dd>group ID of file or directory</dd>
<dt><strong><code>size</code></strong></dt>
<dd>size of file or directory in bytes</dd>
<dt><strong><code>mtime</code></strong></dt>
<dd>modification time of file or directory</dd>
<dt><strong><code>user_data</code></strong></dt>
<dd>optional user data associated with the file or directory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class SnapshotRecord:
    &#34;&#34;&#34;Snapshot details for a file or directory.

    Attributes:
        path: path to file or directory
        is_dir: True if the path is a directory, False if it is a file
        is_file: True if the path is a file, False if it is a directory
        mode: file mode of file or directory
        uid: user ID of file or directory
        gid: group ID of file or directory
        size: size of file or directory in bytes
        mtime: modification time of file or directory
        user_data: optional user data associated with the file or directory
    &#34;&#34;&#34;

    path: str
    is_dir: bool
    is_file: bool
    mode: int
    uid: int
    gid: int
    size: int
    mtime: int
    user_data: Optional[Any] = None

    def asdict(self):
        return dataclasses.asdict(self)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dirsnapshot.dirsnapshot.SnapshotRecord.gid"><code class="name">var <span class="ident">gid</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.SnapshotRecord.is_dir"><code class="name">var <span class="ident">is_dir</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.SnapshotRecord.is_file"><code class="name">var <span class="ident">is_file</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.SnapshotRecord.mode"><code class="name">var <span class="ident">mode</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.SnapshotRecord.mtime"><code class="name">var <span class="ident">mtime</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.SnapshotRecord.path"><code class="name">var <span class="ident">path</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.SnapshotRecord.size"><code class="name">var <span class="ident">size</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.SnapshotRecord.uid"><code class="name">var <span class="ident">uid</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.dirsnapshot.SnapshotRecord.user_data"><code class="name">var <span class="ident">user_data</span> :Â Optional[Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dirsnapshot.dirsnapshot.SnapshotRecord.asdict"><code class="name flex">
<span>def <span class="ident">asdict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asdict(self):
    return dataclasses.asdict(self)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dirsnapshot" href="index.html">dirsnapshot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dirsnapshot.dirsnapshot.create_snapshot" href="#dirsnapshot.dirsnapshot.create_snapshot">create_snapshot</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.create_snapshot_in_memory" href="#dirsnapshot.dirsnapshot.create_snapshot_in_memory">create_snapshot_in_memory</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.load_snapshot" href="#dirsnapshot.dirsnapshot.load_snapshot">load_snapshot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dirsnapshot.dirsnapshot.DirDiff" href="#dirsnapshot.dirsnapshot.DirDiff">DirDiff</a></code></h4>
<ul class="">
<li><code><a title="dirsnapshot.dirsnapshot.DirDiff.compare_records" href="#dirsnapshot.dirsnapshot.DirDiff.compare_records">compare_records</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.DirDiff.diff" href="#dirsnapshot.dirsnapshot.DirDiff.diff">diff</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.DirDiff.report" href="#dirsnapshot.dirsnapshot.DirDiff.report">report</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dirsnapshot.dirsnapshot.DirDiffResults" href="#dirsnapshot.dirsnapshot.DirDiffResults">DirDiffResults</a></code></h4>
<ul class="two-column">
<li><code><a title="dirsnapshot.dirsnapshot.DirDiffResults.added" href="#dirsnapshot.dirsnapshot.DirDiffResults.added">added</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.DirDiffResults.asdict" href="#dirsnapshot.dirsnapshot.DirDiffResults.asdict">asdict</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.DirDiffResults.identical" href="#dirsnapshot.dirsnapshot.DirDiffResults.identical">identical</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.DirDiffResults.json" href="#dirsnapshot.dirsnapshot.DirDiffResults.json">json</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.DirDiffResults.modified" href="#dirsnapshot.dirsnapshot.DirDiffResults.modified">modified</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.DirDiffResults.removed" href="#dirsnapshot.dirsnapshot.DirDiffResults.removed">removed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dirsnapshot.dirsnapshot.DirDiffResults" href="#dirsnapshot.dirsnapshot.DirDiffResults">DirDiffResults</a></code></h4>
<ul class="two-column">
<li><code><a title="dirsnapshot.dirsnapshot.DirDiffResults.added" href="#dirsnapshot.dirsnapshot.DirDiffResults.added">added</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.DirDiffResults.asdict" href="#dirsnapshot.dirsnapshot.DirDiffResults.asdict">asdict</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.DirDiffResults.identical" href="#dirsnapshot.dirsnapshot.DirDiffResults.identical">identical</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.DirDiffResults.json" href="#dirsnapshot.dirsnapshot.DirDiffResults.json">json</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.DirDiffResults.modified" href="#dirsnapshot.dirsnapshot.DirDiffResults.modified">modified</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.DirDiffResults.removed" href="#dirsnapshot.dirsnapshot.DirDiffResults.removed">removed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dirsnapshot.dirsnapshot.SnapshotInfo" href="#dirsnapshot.dirsnapshot.SnapshotInfo">SnapshotInfo</a></code></h4>
<ul class="">
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotInfo.datetime" href="#dirsnapshot.dirsnapshot.SnapshotInfo.datetime">datetime</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotInfo.description" href="#dirsnapshot.dirsnapshot.SnapshotInfo.description">description</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotInfo.directory" href="#dirsnapshot.dirsnapshot.SnapshotInfo.directory">directory</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dirsnapshot.dirsnapshot.SnapshotRecord" href="#dirsnapshot.dirsnapshot.SnapshotRecord">SnapshotRecord</a></code></h4>
<ul class="two-column">
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotRecord.asdict" href="#dirsnapshot.dirsnapshot.SnapshotRecord.asdict">asdict</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotRecord.gid" href="#dirsnapshot.dirsnapshot.SnapshotRecord.gid">gid</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotRecord.is_dir" href="#dirsnapshot.dirsnapshot.SnapshotRecord.is_dir">is_dir</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotRecord.is_file" href="#dirsnapshot.dirsnapshot.SnapshotRecord.is_file">is_file</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotRecord.mode" href="#dirsnapshot.dirsnapshot.SnapshotRecord.mode">mode</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotRecord.mtime" href="#dirsnapshot.dirsnapshot.SnapshotRecord.mtime">mtime</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotRecord.path" href="#dirsnapshot.dirsnapshot.SnapshotRecord.path">path</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotRecord.size" href="#dirsnapshot.dirsnapshot.SnapshotRecord.size">size</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotRecord.uid" href="#dirsnapshot.dirsnapshot.SnapshotRecord.uid">uid</a></code></li>
<li><code><a title="dirsnapshot.dirsnapshot.SnapshotRecord.user_data" href="#dirsnapshot.dirsnapshot.SnapshotRecord.user_data">user_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>