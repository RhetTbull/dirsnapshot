<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dirsnapshot API documentation</title>
<meta name="description" content="dirsnapshot" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>dirsnapshot</code></h1>
</header>
<section id="section-intro">
<p>dirsnapshot</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;dirsnapshot&#34;&#34;&#34;

from ._version import __version__
from .dirsnapshot import (
    DirDiff,
    DirDiffResults,
    DirSnapshot,
    SnapshotInfo,
    SnapshotRecord,
    create_snapshot,
    is_snapshot_file,
    load_snapshot,
)

__all__ = [
    &#34;__version__&#34;,
    &#34;create_snapshot&#34;,
    &#34;DirDiff&#34;,
    &#34;DirDiffResults&#34;,
    &#34;DirSnapshot&#34;,
    &#34;is_snapshot_file&#34;,
    &#34;load_snapshot&#34;,
    &#34;SnapshotInfo&#34;,
    &#34;SnapshotRecord&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="dirsnapshot.dirsnapshot" href="dirsnapshot.html">dirsnapshot.dirsnapshot</a></code></dt>
<dd>
<div class="desc"><p>Report differences between a directory and a previous snapshot of the same directory …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dirsnapshot.create_snapshot"><code class="name flex">
<span>def <span class="ident">create_snapshot</span></span>(<span>dirpath: str, snapshot_db: Optional[str], walk: bool = True, description: Optional[str] = None, filter_function: Optional[Callable[[pathlib.Path], bool]] = None) ‑> dirsnapshot.dirsnapshot.DirSnapshot</span>
</code></dt>
<dd>
<div class="desc"><p>Factory function to create a snapshot of a directory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dir</code></strong></dt>
<dd>path to directory to snapshot</dd>
<dt><strong><code>snapshot_db</code></strong></dt>
<dd>path to database to write snapshot to or None to create database in memory</dd>
<dt><strong><code>walk</code></strong></dt>
<dd>if True, walk the directory tree and add all files and directories</dd>
<dt><strong><code>description</code></strong></dt>
<dd>optional description of the snapshot</dd>
<dt><strong><code>filter</code></strong></dt>
<dd>optional function to filter out files and directories; should return True if the file or directory should be included in the snapshot</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DirSnapshot object</p>
<h2 id="raises">Raises</h2>
<p>ValueError if snapshot_db already exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_snapshot(
    dirpath: str,
    snapshot_db: Optional[str],
    walk: bool = True,
    description: Optional[str] = None,
    filter_function: Optional[Callable[[pathlib.Path], bool]] = None,
) -&gt; &#34;DirSnapshot&#34;:
    &#34;&#34;&#34;Factory function to create a snapshot of a directory

    Args:
        dir: path to directory to snapshot
        snapshot_db: path to database to write snapshot to or None to create database in memory
        walk: if True, walk the directory tree and add all files and directories
        description: optional description of the snapshot
        filter: optional function to filter out files and directories; should return True if the file or directory should be included in the snapshot

    Returns:
        DirSnapshot object

    Raises:
        ValueError if snapshot_db already exists
    &#34;&#34;&#34;

    snapshot_db = snapshot_db or &#34;:memory:&#34;
    if snapshot_db != &#34;:memory:&#34; and pathexists(snapshot_db):
        raise ValueError(f&#34;Snapshot database {snapshot_db} already exists&#34;)

    snapshot = DirSnapshot()
    snapshot.init_from_dir(dirpath, snapshot_db, walk, description, filter_function)
    return snapshot</code></pre>
</details>
</dd>
<dt id="dirsnapshot.is_snapshot_file"><code class="name flex">
<span>def <span class="ident">is_snapshot_file</span></span>(<span>pathstr: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if the given path is a snapshot database file, otherwise False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_snapshot_file(pathstr: str) -&gt; bool:
    &#34;&#34;&#34;Return True if the given path is a snapshot database file, otherwise False&#34;&#34;&#34;
    pathstr = os.path.abspath(os.path.expanduser(pathstr))
    try:
        conn = sqlite3.connect(f&#34;file:{pathstr}?mode=ro&#34;, uri=True)
        cursor = conn.cursor()
        return (
            cursor.execute(
                &#34;&#34;&#34;
        SELECT count(*)
        FROM sqlite_master
        WHERE type=&#39;table&#39;
        AND name=&#39;snapshot&#39;;
        &#34;&#34;&#34;
            ).fetchone()[0]
            == 1
        )
    except Exception as e:
        return False</code></pre>
</details>
</dd>
<dt id="dirsnapshot.load_snapshot"><code class="name flex">
<span>def <span class="ident">load_snapshot</span></span>(<span>snapshot_db: str) ‑> dirsnapshot.dirsnapshot.DirSnapshot</span>
</code></dt>
<dd>
<div class="desc"><p>Factory function to load a snapshot from a database file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snapshot_db</code></strong></dt>
<dd>path to database file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DirSnapshot object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_snapshot(snapshot_db: str) -&gt; &#34;DirSnapshot&#34;:
    &#34;&#34;&#34;Factory function to load a snapshot from a database file

    Args:
        snapshot_db: path to database file

    Returns:
        DirSnapshot object
    &#34;&#34;&#34;
    snapshot = DirSnapshot()
    snapshot.load_from_snapshot_db(snapshot_db)
    return snapshot</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dirsnapshot.DirDiff"><code class="flex name class">
<span>class <span class="ident">DirDiff</span></span>
<span>(</span><span>snapshot_a: Union[str, dirsnapshot.dirsnapshot.DirSnapshot], directory_or_snapshot_b: Union[str, dirsnapshot.dirsnapshot.DirSnapshot], walk: bool = True, filter_function: Optional[Callable[[pathlib.Path], bool]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the DirDiff instance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snapshot_a</code></strong></dt>
<dd>path to previous snapshot database to compare or a DirSnapshot instance</dd>
<dt><strong><code>directory_or_snapshot_b</code></strong></dt>
<dd>path to current snapshot database, DirSnapshot instance, or path to directory to compare snapshot_a to</dd>
<dt><strong><code>walk</code></strong></dt>
<dd>if True, walks the directory tree and recursively adds all files and directories</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirDiff:
    def __init__(
        self,
        snapshot_a: Union[str, DirSnapshot],
        directory_or_snapshot_b: Union[str, DirSnapshot],
        walk: bool = True,
        filter_function: Optional[Callable[[pathlib.Path], bool]] = None,
    ):
        &#34;&#34;&#34;Initialize the DirDiff instance

        Args:
            snapshot_a: path to previous snapshot database to compare or a DirSnapshot instance
            directory_or_snapshot_b: path to current snapshot database, DirSnapshot instance, or path to directory to compare snapshot_a to
            walk: if True, walks the directory tree and recursively adds all files and directories
        &#34;&#34;&#34;

        if isinstance(snapshot_a, str):
            self.snapshot_a = load_snapshot(snapshot_a)
        elif isinstance(snapshot_a, DirSnapshot):
            self.snapshot_a = snapshot_a
        else:
            raise ValueError(
                f&#34;{snapshot_a} is not a snapshot database or DirSnapshot instance&#34;
            )

        if isinstance(directory_or_snapshot_b, DirSnapshot):
            self.snapshot_b = directory_or_snapshot_b
        elif os.path.isdir(directory_or_snapshot_b):
            self.snapshot_b = create_snapshot(directory_or_snapshot_b, None, walk)
        elif is_snapshot_file(directory_or_snapshot_b):
            self.snapshot_b = load_snapshot(directory_or_snapshot_b)
        else:
            raise ValueError(
                f&#34;{directory_or_snapshot_b} is not a directory or a snapshot database&#34;
            )

        self._diff: Optional[DirDiffResults] = None
        self.walk = walk
        self.filter_function = filter_function

    def diff(
        self,
        dirs: bool = True,
        compare_function: Optional[
            Callable[[SnapshotRecord, SnapshotRecord], bool]
        ] = None,
    ) -&gt; DirDiffResults:
        &#34;&#34;&#34;Compare the current directory or snapshot to the previous snapshot

        Args:
            `dirs`: if True, includes directories in the comparison, otherwise only files are compared (if dirs==True, directories will show as modified if any file contained in the directory has been modified)
            `compare_function`: optional function to filter the results, receives a pair of SnapshotRecords and returns True if the pair are equal, otherwise False

        Returns:
            diff results as DirDiffResults instance
        &#34;&#34;&#34;
        self._diff = self._diff_snapshots(dirs, compare_function)
        return self._diff

    def report(self, include_identical=False) -&gt; None:
        &#34;&#34;&#34;Print a report of the diff to stdout.

        Args:
            include_identical: if True, print files that are identical
        &#34;&#34;&#34;

        diff = self.diff()

        info_a = self.snapshot_a.info
        info_b = self.snapshot_b.info
        print(
            f&#34;diff &#39;{info_a.directory}&#39; {info_a.datetime} ({info_a.description}) vs {info_b.datetime} ({info_b.description})&#34;
        )
        print(&#34;Added: &#34;)
        print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.added]))
        if diff.added:
            print()
        print(&#34;Removed: &#34;)
        print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.removed]))
        if diff.removed:
            print()
        print(&#34;Modified: &#34;)
        print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.modified]))
        if diff.modified and include_identical:
            print()
        if include_identical:
            print(&#34;Identical: &#34;)
            print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.identical]))

    def compare_records(
        self, record_a: SnapshotRecord, record_b: SnapshotRecord
    ) -&gt; bool:
        &#34;&#34;&#34;The default compare function for DirDiff.diff();
        override this in your subclass to implement custom compare, or use compare_function arg to diff

        Args:
            record_a: first SnapshotRecord to compare
            record_b: second SnapshotRecord to compare

        Returns:
            True if the records are equal, otherwise False
        &#34;&#34;&#34;
        return (
            record_a.is_dir == record_b.is_dir
            and record_a.is_file == record_b.is_file
            and record_a.mode == record_b.mode
            and record_a.uid == record_b.uid
            and record_a.gid == record_b.gid
            and record_a.size == record_b.size
            and record_a.mtime == record_b.mtime
        )

    def _diff_snapshots(
        self,
        dirs: bool,
        compare_function: Optional[
            Callable[[SnapshotRecord, SnapshotRecord], bool]
        ] = None,
    ) -&gt; DirDiffResults:
        &#34;&#34;&#34;Diff two database snapshots

        Returns:
            DirDiffResults instance
        &#34;&#34;&#34;
        diffresults: Dict = {
            &#34;added&#34;: [],
            &#34;removed&#34;: [],
            &#34;modified&#34;: [],
            &#34;identical&#34;: [],
        }

        compare_function = compare_function or self.compare_records

        paths_b = {}
        for row_b in self.snapshot_b.records():
            if self.filter_function and not self.filter_function(row_b.Path):
                continue
            if not dirs and row_b.is_dir:
                continue
            paths_b[row_b.path] = 1
            if row_a := self.snapshot_a.record(row_b.path):
                if not compare_function(row_a, row_b):
                    diffresults[&#34;modified&#34;].append(row_b.path)
                else:
                    diffresults[&#34;identical&#34;].append(row_b.path)
            else:
                diffresults[&#34;added&#34;].append(row_b.path)
        for row_a in self.snapshot_a.records():
            if self.filter_function and not self.filter_function(row_a.Path):
                continue
            if not dirs and row_a.is_dir:
                continue
            if row_a.path not in paths_b:
                diffresults[&#34;removed&#34;].append(row_a.path)

        return DirDiffResults(**diffresults)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dirsnapshot.DirDiff.compare_records"><code class="name flex">
<span>def <span class="ident">compare_records</span></span>(<span>self, record_a: <a title="dirsnapshot.dirsnapshot.SnapshotRecord" href="dirsnapshot.html#dirsnapshot.dirsnapshot.SnapshotRecord">SnapshotRecord</a>, record_b: <a title="dirsnapshot.dirsnapshot.SnapshotRecord" href="dirsnapshot.html#dirsnapshot.dirsnapshot.SnapshotRecord">SnapshotRecord</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>The default compare function for DirDiff.diff();
override this in your subclass to implement custom compare, or use compare_function arg to diff</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>record_a</code></strong></dt>
<dd>first SnapshotRecord to compare</dd>
<dt><strong><code>record_b</code></strong></dt>
<dd>second SnapshotRecord to compare</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if the records are equal, otherwise False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_records(
    self, record_a: SnapshotRecord, record_b: SnapshotRecord
) -&gt; bool:
    &#34;&#34;&#34;The default compare function for DirDiff.diff();
    override this in your subclass to implement custom compare, or use compare_function arg to diff

    Args:
        record_a: first SnapshotRecord to compare
        record_b: second SnapshotRecord to compare

    Returns:
        True if the records are equal, otherwise False
    &#34;&#34;&#34;
    return (
        record_a.is_dir == record_b.is_dir
        and record_a.is_file == record_b.is_file
        and record_a.mode == record_b.mode
        and record_a.uid == record_b.uid
        and record_a.gid == record_b.gid
        and record_a.size == record_b.size
        and record_a.mtime == record_b.mtime
    )</code></pre>
</details>
</dd>
<dt id="dirsnapshot.DirDiff.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>self, dirs: bool = True, compare_function: Optional[Callable[[<a title="dirsnapshot.dirsnapshot.SnapshotRecord" href="dirsnapshot.html#dirsnapshot.dirsnapshot.SnapshotRecord">SnapshotRecord</a>, <a title="dirsnapshot.dirsnapshot.SnapshotRecord" href="dirsnapshot.html#dirsnapshot.dirsnapshot.SnapshotRecord">SnapshotRecord</a>], bool]] = None) ‑> <a title="dirsnapshot.dirsnapshot.DirDiffResults" href="dirsnapshot.html#dirsnapshot.dirsnapshot.DirDiffResults">DirDiffResults</a></span>
</code></dt>
<dd>
<div class="desc"><p>Compare the current directory or snapshot to the previous snapshot</p>
<h2 id="args">Args</h2>
<p><code>dirs</code>: if True, includes directories in the comparison, otherwise only files are compared (if dirs==True, directories will show as modified if any file contained in the directory has been modified)
<code>compare_function</code>: optional function to filter the results, receives a pair of SnapshotRecords and returns True if the pair are equal, otherwise False</p>
<h2 id="returns">Returns</h2>
<p>diff results as DirDiffResults instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(
    self,
    dirs: bool = True,
    compare_function: Optional[
        Callable[[SnapshotRecord, SnapshotRecord], bool]
    ] = None,
) -&gt; DirDiffResults:
    &#34;&#34;&#34;Compare the current directory or snapshot to the previous snapshot

    Args:
        `dirs`: if True, includes directories in the comparison, otherwise only files are compared (if dirs==True, directories will show as modified if any file contained in the directory has been modified)
        `compare_function`: optional function to filter the results, receives a pair of SnapshotRecords and returns True if the pair are equal, otherwise False

    Returns:
        diff results as DirDiffResults instance
    &#34;&#34;&#34;
    self._diff = self._diff_snapshots(dirs, compare_function)
    return self._diff</code></pre>
</details>
</dd>
<dt id="dirsnapshot.DirDiff.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self, include_identical=False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Print a report of the diff to stdout.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>include_identical</code></strong></dt>
<dd>if True, print files that are identical</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report(self, include_identical=False) -&gt; None:
    &#34;&#34;&#34;Print a report of the diff to stdout.

    Args:
        include_identical: if True, print files that are identical
    &#34;&#34;&#34;

    diff = self.diff()

    info_a = self.snapshot_a.info
    info_b = self.snapshot_b.info
    print(
        f&#34;diff &#39;{info_a.directory}&#39; {info_a.datetime} ({info_a.description}) vs {info_b.datetime} ({info_b.description})&#34;
    )
    print(&#34;Added: &#34;)
    print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.added]))
    if diff.added:
        print()
    print(&#34;Removed: &#34;)
    print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.removed]))
    if diff.removed:
        print()
    print(&#34;Modified: &#34;)
    print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.modified]))
    if diff.modified and include_identical:
        print()
    if include_identical:
        print(&#34;Identical: &#34;)
        print(&#34;\n&#34;.join([f&#34;    {f}&#34; for f in diff.identical]))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dirsnapshot.DirDiffResults"><code class="flex name class">
<span>class <span class="ident">DirDiffResults</span></span>
<span>(</span><span>added: List[str], removed: List[str], modified: List[str], identical: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Results of a directory comparison as returned by DirDiff.diff()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class DirDiffResults:
    &#34;&#34;&#34;Results of a directory comparison as returned by DirDiff.diff()&#34;&#34;&#34;

    added: List[str]
    removed: List[str]
    modified: List[str]
    identical: List[str]

    def asdict(self):
        return dataclasses.asdict(self)

    def json(self):
        return json.dumps(self.asdict())</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dirsnapshot.DirDiffResults.added"><code class="name">var <span class="ident">added</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.DirDiffResults.identical"><code class="name">var <span class="ident">identical</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.DirDiffResults.modified"><code class="name">var <span class="ident">modified</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.DirDiffResults.removed"><code class="name">var <span class="ident">removed</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dirsnapshot.DirDiffResults.asdict"><code class="name flex">
<span>def <span class="ident">asdict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asdict(self):
    return dataclasses.asdict(self)</code></pre>
</details>
</dd>
<dt id="dirsnapshot.DirDiffResults.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json(self):
    return json.dumps(self.asdict())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dirsnapshot.DirSnapshot"><code class="flex name class">
<span>class <span class="ident">DirSnapshot</span></span>
</code></dt>
<dd>
<div class="desc"><p>Create a snapshot of a directory for use with DirDiff</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirSnapshot:
    &#34;&#34;&#34;Create a snapshot of a directory for use with DirDiff&#34;&#34;&#34;

    def __init__(self):
        pass

    def init_from_dir(
        self,
        dirpath: str,
        snapshot_db: str,
        walk: bool = True,
        description: Optional[str] = None,
        filter_function: Optional[Callable[[pathlib.Path], bool]] = None,
    ):
        &#34;&#34;&#34;Create a snapshot from a directory

        Args:
            dirpath: path to the directory to snapshot
            snapshot_db: path to database to write snapshot to
            walk: if True, walk the directory tree and add all files and directories
            description: optional description of the snapshot
            filter: optional function to filter out files and directories; should return True if the file or directory should be included in the snapshot
        &#34;&#34;&#34;
        if pathexists(snapshot_db):
            raise ValueError(f&#34;Snapshot database {snapshot_db} already exists&#34;)
        if not os.path.isdir(dirpath):
            raise ValueError(
                f&#34;Directory {dirpath} does not exist or is not a directory&#34;
            )

        conn, cursor = self._create_snapshot_db(snapshot_db, dirpath, description)
        self.conn = conn
        self._snapshot(dirpath, walk, conn, cursor, filter_function)

    def load_from_snapshot_db(self, snapshot_db: str):
        &#34;&#34;&#34;Load a snapshot from a database file

        Args:
            snapshot_db: path to database file
        &#34;&#34;&#34;
        if not is_snapshot_file(snapshot_db):
            raise ValueError(f&#34;{snapshot_db} is not a snapshot database&#34;)
        conn, _ = self._open_snapshot_db(snapshot_db)
        self.conn = conn

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;Return the description of the snapshot&#34;&#34;&#34;
        return self.info.description

    @property
    def directory(self) -&gt; str:
        &#34;&#34;&#34;Return the directory of the snapshot&#34;&#34;&#34;
        return self.info.directory

    @property
    def datetime(self) -&gt; datetime.datetime:
        &#34;&#34;&#34;Return the datetime of the snapshot&#34;&#34;&#34;
        return datetime.datetime.fromisoformat(self.info.datetime)

    @property
    def info(self) -&gt; SnapshotInfo:
        &#34;&#34;&#34;Return info about a snapshot as a named tuple.

        Returns:
            SnapshotInfo named tuple
        &#34;&#34;&#34;
        cursor = self.conn.cursor()
        cursor.execute(
            &#34;SELECT description, directory, datetime FROM about ORDER BY datetime DESC LIMIT 1&#34;
        )
        description, directory, dt = cursor.fetchone()
        return SnapshotInfo(description, directory, dt)

    def files(self) -&gt; Iterator[str]:
        &#34;&#34;&#34;Generator to return all files in the snapshot&#34;&#34;&#34;
        cursor = self.conn.cursor()
        cursor.execute(&#34;SELECT path FROM snapshot&#34;)
        for row in cursor:
            yield row[0]

    def record(self, filepath: str) -&gt; Optional[SnapshotRecord]:
        &#34;&#34;&#34;Return the snapshot record for a filepath or None if the filepath is not in the snapshot&#34;&#34;&#34;
        cursor = self.conn.cursor()
        cursor.execute(
            &#34;SELECT path, is_dir, is_file, st_mode, st_uid, st_gid, st_size, st_mtime, user_data FROM snapshot WHERE path = ?&#34;,
            (filepath,),
        )
        results = cursor.fetchone()
        if results is None:
            return None
        return SnapshotRecord(*results)

    def records(self) -&gt; Iterator[SnapshotRecord]:
        &#34;&#34;&#34;Generator to return all files in the snapshot&#34;&#34;&#34;
        cursor = self.conn.cursor()
        cursor.execute(
            &#34;SELECT path, is_dir, is_file, st_mode, st_uid, st_gid, st_size, st_mtime FROM snapshot&#34;
        )
        for row in cursor:
            yield SnapshotRecord(*row)

    def _create_snapshot_db(
        self,
        dbpath: str,
        dirpath: Optional[str] = None,
        description: Optional[str] = None,
    ) -&gt; Tuple[sqlite3.Connection, sqlite3.Cursor]:
        &#34;&#34;&#34;Initialize a snapshot db, and return a connection and cursor

        Args:
            dbpath: path to database to open
            dirpath: path to the directory to snapshot
            description: optional description of the snapshot

        Returns:
            sqlite3.Connection, sqlite3.Cursor
        &#34;&#34;&#34;

        conn = sqlite3.connect(dbpath)
        cursor = conn.cursor()

        cursor.execute(
            &#34;&#34;&#34;
            CREATE TABLE IF NOT EXISTS snapshot (
                path TEXT, 
                is_dir INTEGER,
                is_file INTEGER,
                st_mode INTEGER, 
                st_uid INTEGER, 
                st_gid INTEGER, 
                st_size INTEGER, 
                st_mtime INTEGER,
                user_data BLOB
                );
        &#34;&#34;&#34;
        )

        cursor.execute(
            &#34;&#34;&#34;
            CREATE TABLE IF NOT EXISTS _metadata (
                description TEXT, source TEXT, version TEXT, created_at DATETIME);
        &#34;&#34;&#34;
        )

        cursor.execute(
            &#34;&#34;&#34;
            CREATE TABLE IF NOT EXISTS about (
                description TEXT, directory TEXT, datetime DATETIME);
        &#34;&#34;&#34;
        )

        cursor.execute(
            &#34;&#34;&#34;
            CREATE INDEX IF NOT EXISTS snapshot_path_index ON snapshot (path);
            &#34;&#34;&#34;
        )

        now = datetime.datetime.now().isoformat()
        description = description or f&#34;Snapshot created at {now}&#34;
        dirpath = dirpath or &#34;&#34;
        cursor.execute(
            &#34;INSERT INTO about VALUES (?, ?, ?)&#34;, (description, dirpath, now)
        )
        cursor.execute(
            &#34;INSERT INTO _metadata VALUES (?, ?, ?, ?)&#34;,
            (METADATA_DESCRIPTION, METADATA_SOURCE, __version__, now),
        )
        conn.commit()
        return conn, cursor

    def _open_snapshot_db(
        self, dbpath: str
    ) -&gt; Tuple[sqlite3.Connection, sqlite3.Cursor]:
        &#34;&#34;&#34;Open a snapshot db, and return a connection and cursor

        Args:
            dbpath: path to database to open

        Returns:
            sqlite3.Connection, sqlite3.Cursor
        &#34;&#34;&#34;
        conn = sqlite3.connect(dbpath)
        cursor = conn.cursor()
        return conn, cursor

    def _add_snapshot_db_entry(
        self,
        cursor: sqlite3.Cursor,
        pathstr: str,
        statinfo: os.stat_result,
        is_dir: bool,
        is_file: bool,
    ):
        cursor.execute(
            &#34;&#34;&#34;INSERT INTO snapshot VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)&#34;&#34;&#34;,
            (
                pathstr,
                1 if is_dir else 0,
                1 if is_file else 0,
                statinfo.st_mode,
                statinfo.st_uid,
                statinfo.st_gid,
                statinfo.st_size,
                statinfo.st_mtime,
                b&#34;&#34;,
            ),
        )

    def _snapshot(
        self,
        dirpath: str,
        walk: bool,
        conn: sqlite3.Connection,
        cursor: sqlite3.Cursor,
        filter_function: Callable[[pathlib.Path], bool] = None,
    ):
        for current_dirpath, dirnames, filenames in oswalk(dirpath):
            for dirname in dirnames:
                pathstr = joinpath(current_dirpath, dirname)
                if filter_function and not filter_function(Path(pathstr)):
                    continue
                statinfo = osstat(pathstr)
                self._add_snapshot_db_entry(
                    cursor, pathstr, statinfo, is_dir=True, is_file=False
                )

            for filename in filenames:
                pathstr = joinpath(current_dirpath, filename)
                if filter_function and not filter_function(Path(pathstr)):
                    continue
                statinfo = osstat(pathstr)
                self._add_snapshot_db_entry(
                    cursor, pathstr, statinfo, is_dir=False, is_file=True
                )
            if not walk:
                # don&#39;t continue walking the the tree
                break

        conn.commit()

    def __len__(self):
        return self.conn.execute(&#34;SELECT COUNT(*) FROM snapshot&#34;).fetchone()[0]</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="dirsnapshot.DirSnapshot.datetime"><code class="name">var <span class="ident">datetime</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"><p>Return the datetime of the snapshot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def datetime(self) -&gt; datetime.datetime:
    &#34;&#34;&#34;Return the datetime of the snapshot&#34;&#34;&#34;
    return datetime.datetime.fromisoformat(self.info.datetime)</code></pre>
</details>
</dd>
<dt id="dirsnapshot.DirSnapshot.description"><code class="name">var <span class="ident">description</span> : str</code></dt>
<dd>
<div class="desc"><p>Return the description of the snapshot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self) -&gt; str:
    &#34;&#34;&#34;Return the description of the snapshot&#34;&#34;&#34;
    return self.info.description</code></pre>
</details>
</dd>
<dt id="dirsnapshot.DirSnapshot.directory"><code class="name">var <span class="ident">directory</span> : str</code></dt>
<dd>
<div class="desc"><p>Return the directory of the snapshot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def directory(self) -&gt; str:
    &#34;&#34;&#34;Return the directory of the snapshot&#34;&#34;&#34;
    return self.info.directory</code></pre>
</details>
</dd>
<dt id="dirsnapshot.DirSnapshot.info"><code class="name">var <span class="ident">info</span> : <a title="dirsnapshot.dirsnapshot.SnapshotInfo" href="dirsnapshot.html#dirsnapshot.dirsnapshot.SnapshotInfo">SnapshotInfo</a></code></dt>
<dd>
<div class="desc"><p>Return info about a snapshot as a named tuple.</p>
<h2 id="returns">Returns</h2>
<p>SnapshotInfo named tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def info(self) -&gt; SnapshotInfo:
    &#34;&#34;&#34;Return info about a snapshot as a named tuple.

    Returns:
        SnapshotInfo named tuple
    &#34;&#34;&#34;
    cursor = self.conn.cursor()
    cursor.execute(
        &#34;SELECT description, directory, datetime FROM about ORDER BY datetime DESC LIMIT 1&#34;
    )
    description, directory, dt = cursor.fetchone()
    return SnapshotInfo(description, directory, dt)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dirsnapshot.DirSnapshot.files"><code class="name flex">
<span>def <span class="ident">files</span></span>(<span>self) ‑> Iterator[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Generator to return all files in the snapshot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files(self) -&gt; Iterator[str]:
    &#34;&#34;&#34;Generator to return all files in the snapshot&#34;&#34;&#34;
    cursor = self.conn.cursor()
    cursor.execute(&#34;SELECT path FROM snapshot&#34;)
    for row in cursor:
        yield row[0]</code></pre>
</details>
</dd>
<dt id="dirsnapshot.DirSnapshot.init_from_dir"><code class="name flex">
<span>def <span class="ident">init_from_dir</span></span>(<span>self, dirpath: str, snapshot_db: str, walk: bool = True, description: Optional[str] = None, filter_function: Optional[Callable[[pathlib.Path], bool]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a snapshot from a directory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dirpath</code></strong></dt>
<dd>path to the directory to snapshot</dd>
<dt><strong><code>snapshot_db</code></strong></dt>
<dd>path to database to write snapshot to</dd>
<dt><strong><code>walk</code></strong></dt>
<dd>if True, walk the directory tree and add all files and directories</dd>
<dt><strong><code>description</code></strong></dt>
<dd>optional description of the snapshot</dd>
<dt><strong><code>filter</code></strong></dt>
<dd>optional function to filter out files and directories; should return True if the file or directory should be included in the snapshot</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_from_dir(
    self,
    dirpath: str,
    snapshot_db: str,
    walk: bool = True,
    description: Optional[str] = None,
    filter_function: Optional[Callable[[pathlib.Path], bool]] = None,
):
    &#34;&#34;&#34;Create a snapshot from a directory

    Args:
        dirpath: path to the directory to snapshot
        snapshot_db: path to database to write snapshot to
        walk: if True, walk the directory tree and add all files and directories
        description: optional description of the snapshot
        filter: optional function to filter out files and directories; should return True if the file or directory should be included in the snapshot
    &#34;&#34;&#34;
    if pathexists(snapshot_db):
        raise ValueError(f&#34;Snapshot database {snapshot_db} already exists&#34;)
    if not os.path.isdir(dirpath):
        raise ValueError(
            f&#34;Directory {dirpath} does not exist or is not a directory&#34;
        )

    conn, cursor = self._create_snapshot_db(snapshot_db, dirpath, description)
    self.conn = conn
    self._snapshot(dirpath, walk, conn, cursor, filter_function)</code></pre>
</details>
</dd>
<dt id="dirsnapshot.DirSnapshot.load_from_snapshot_db"><code class="name flex">
<span>def <span class="ident">load_from_snapshot_db</span></span>(<span>self, snapshot_db: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a snapshot from a database file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snapshot_db</code></strong></dt>
<dd>path to database file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_from_snapshot_db(self, snapshot_db: str):
    &#34;&#34;&#34;Load a snapshot from a database file

    Args:
        snapshot_db: path to database file
    &#34;&#34;&#34;
    if not is_snapshot_file(snapshot_db):
        raise ValueError(f&#34;{snapshot_db} is not a snapshot database&#34;)
    conn, _ = self._open_snapshot_db(snapshot_db)
    self.conn = conn</code></pre>
</details>
</dd>
<dt id="dirsnapshot.DirSnapshot.record"><code class="name flex">
<span>def <span class="ident">record</span></span>(<span>self, filepath: str) ‑> Optional[<a title="dirsnapshot.dirsnapshot.SnapshotRecord" href="dirsnapshot.html#dirsnapshot.dirsnapshot.SnapshotRecord">SnapshotRecord</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the snapshot record for a filepath or None if the filepath is not in the snapshot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record(self, filepath: str) -&gt; Optional[SnapshotRecord]:
    &#34;&#34;&#34;Return the snapshot record for a filepath or None if the filepath is not in the snapshot&#34;&#34;&#34;
    cursor = self.conn.cursor()
    cursor.execute(
        &#34;SELECT path, is_dir, is_file, st_mode, st_uid, st_gid, st_size, st_mtime, user_data FROM snapshot WHERE path = ?&#34;,
        (filepath,),
    )
    results = cursor.fetchone()
    if results is None:
        return None
    return SnapshotRecord(*results)</code></pre>
</details>
</dd>
<dt id="dirsnapshot.DirSnapshot.records"><code class="name flex">
<span>def <span class="ident">records</span></span>(<span>self) ‑> Iterator[<a title="dirsnapshot.dirsnapshot.SnapshotRecord" href="dirsnapshot.html#dirsnapshot.dirsnapshot.SnapshotRecord">SnapshotRecord</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Generator to return all files in the snapshot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def records(self) -&gt; Iterator[SnapshotRecord]:
    &#34;&#34;&#34;Generator to return all files in the snapshot&#34;&#34;&#34;
    cursor = self.conn.cursor()
    cursor.execute(
        &#34;SELECT path, is_dir, is_file, st_mode, st_uid, st_gid, st_size, st_mtime FROM snapshot&#34;
    )
    for row in cursor:
        yield SnapshotRecord(*row)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dirsnapshot.SnapshotInfo"><code class="flex name class">
<span>class <span class="ident">SnapshotInfo</span></span>
<span>(</span><span>description, directory, datetime)</span>
</code></dt>
<dd>
<div class="desc"><p>SnapshotInfo(description, directory, datetime)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="dirsnapshot.SnapshotInfo.datetime"><code class="name">var <span class="ident">datetime</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="dirsnapshot.SnapshotInfo.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="dirsnapshot.SnapshotInfo.directory"><code class="name">var <span class="ident">directory</span></code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="dirsnapshot.SnapshotRecord"><code class="flex name class">
<span>class <span class="ident">SnapshotRecord</span></span>
<span>(</span><span>path: str, is_dir: bool, is_file: bool, mode: int, uid: int, gid: int, size: int, mtime: int, user_data: Optional[Any] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Snapshot details for a file or directory.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>path to file or directory</dd>
<dt><strong><code>is_dir</code></strong></dt>
<dd>True if the path is a directory, False if it is a file</dd>
<dt><strong><code>is_file</code></strong></dt>
<dd>True if the path is a file, False if it is a directory</dd>
<dt><strong><code>mode</code></strong></dt>
<dd>file mode of file or directory</dd>
<dt><strong><code>uid</code></strong></dt>
<dd>user ID of file or directory</dd>
<dt><strong><code>gid</code></strong></dt>
<dd>group ID of file or directory</dd>
<dt><strong><code>size</code></strong></dt>
<dd>size of file or directory in bytes</dd>
<dt><strong><code>mtime</code></strong></dt>
<dd>modification time of file or directory</dd>
<dt><strong><code>user_data</code></strong></dt>
<dd>optional user data associated with the file or directory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class SnapshotRecord:
    &#34;&#34;&#34;Snapshot details for a file or directory.

    Attributes:
        path: path to file or directory
        is_dir: True if the path is a directory, False if it is a file
        is_file: True if the path is a file, False if it is a directory
        mode: file mode of file or directory
        uid: user ID of file or directory
        gid: group ID of file or directory
        size: size of file or directory in bytes
        mtime: modification time of file or directory
        user_data: optional user data associated with the file or directory
    &#34;&#34;&#34;

    path: str
    is_dir: bool
    is_file: bool
    mode: int
    uid: int
    gid: int
    size: int
    mtime: int
    user_data: Optional[Any] = None

    @property
    def Path(self) -&gt; pathlib.Path:
        &#34;&#34;&#34;pathlib.Path object for the file or directory&#34;&#34;&#34;
        return Path(self.path)

    def asdict(self):
        &#34;&#34;&#34;Return a dict representation of the snapshot record&#34;&#34;&#34;
        return dataclasses.asdict(self)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="dirsnapshot.SnapshotRecord.gid"><code class="name">var <span class="ident">gid</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.SnapshotRecord.is_dir"><code class="name">var <span class="ident">is_dir</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.SnapshotRecord.is_file"><code class="name">var <span class="ident">is_file</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.SnapshotRecord.mode"><code class="name">var <span class="ident">mode</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.SnapshotRecord.mtime"><code class="name">var <span class="ident">mtime</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.SnapshotRecord.path"><code class="name">var <span class="ident">path</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.SnapshotRecord.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.SnapshotRecord.uid"><code class="name">var <span class="ident">uid</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dirsnapshot.SnapshotRecord.user_data"><code class="name">var <span class="ident">user_data</span> : Optional[Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="dirsnapshot.SnapshotRecord.Path"><code class="name">var <span class="ident">Path</span> : pathlib.Path</code></dt>
<dd>
<div class="desc"><p>pathlib.Path object for the file or directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Path(self) -&gt; pathlib.Path:
    &#34;&#34;&#34;pathlib.Path object for the file or directory&#34;&#34;&#34;
    return Path(self.path)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dirsnapshot.SnapshotRecord.asdict"><code class="name flex">
<span>def <span class="ident">asdict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dict representation of the snapshot record</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asdict(self):
    &#34;&#34;&#34;Return a dict representation of the snapshot record&#34;&#34;&#34;
    return dataclasses.asdict(self)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="dirsnapshot.dirsnapshot" href="dirsnapshot.html">dirsnapshot.dirsnapshot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dirsnapshot.create_snapshot" href="#dirsnapshot.create_snapshot">create_snapshot</a></code></li>
<li><code><a title="dirsnapshot.is_snapshot_file" href="#dirsnapshot.is_snapshot_file">is_snapshot_file</a></code></li>
<li><code><a title="dirsnapshot.load_snapshot" href="#dirsnapshot.load_snapshot">load_snapshot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dirsnapshot.DirDiff" href="#dirsnapshot.DirDiff">DirDiff</a></code></h4>
<ul class="">
<li><code><a title="dirsnapshot.DirDiff.compare_records" href="#dirsnapshot.DirDiff.compare_records">compare_records</a></code></li>
<li><code><a title="dirsnapshot.DirDiff.diff" href="#dirsnapshot.DirDiff.diff">diff</a></code></li>
<li><code><a title="dirsnapshot.DirDiff.report" href="#dirsnapshot.DirDiff.report">report</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dirsnapshot.DirDiffResults" href="#dirsnapshot.DirDiffResults">DirDiffResults</a></code></h4>
<ul class="two-column">
<li><code><a title="dirsnapshot.DirDiffResults.added" href="#dirsnapshot.DirDiffResults.added">added</a></code></li>
<li><code><a title="dirsnapshot.DirDiffResults.asdict" href="#dirsnapshot.DirDiffResults.asdict">asdict</a></code></li>
<li><code><a title="dirsnapshot.DirDiffResults.identical" href="#dirsnapshot.DirDiffResults.identical">identical</a></code></li>
<li><code><a title="dirsnapshot.DirDiffResults.json" href="#dirsnapshot.DirDiffResults.json">json</a></code></li>
<li><code><a title="dirsnapshot.DirDiffResults.modified" href="#dirsnapshot.DirDiffResults.modified">modified</a></code></li>
<li><code><a title="dirsnapshot.DirDiffResults.removed" href="#dirsnapshot.DirDiffResults.removed">removed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dirsnapshot.DirSnapshot" href="#dirsnapshot.DirSnapshot">DirSnapshot</a></code></h4>
<ul class="">
<li><code><a title="dirsnapshot.DirSnapshot.datetime" href="#dirsnapshot.DirSnapshot.datetime">datetime</a></code></li>
<li><code><a title="dirsnapshot.DirSnapshot.description" href="#dirsnapshot.DirSnapshot.description">description</a></code></li>
<li><code><a title="dirsnapshot.DirSnapshot.directory" href="#dirsnapshot.DirSnapshot.directory">directory</a></code></li>
<li><code><a title="dirsnapshot.DirSnapshot.files" href="#dirsnapshot.DirSnapshot.files">files</a></code></li>
<li><code><a title="dirsnapshot.DirSnapshot.info" href="#dirsnapshot.DirSnapshot.info">info</a></code></li>
<li><code><a title="dirsnapshot.DirSnapshot.init_from_dir" href="#dirsnapshot.DirSnapshot.init_from_dir">init_from_dir</a></code></li>
<li><code><a title="dirsnapshot.DirSnapshot.load_from_snapshot_db" href="#dirsnapshot.DirSnapshot.load_from_snapshot_db">load_from_snapshot_db</a></code></li>
<li><code><a title="dirsnapshot.DirSnapshot.record" href="#dirsnapshot.DirSnapshot.record">record</a></code></li>
<li><code><a title="dirsnapshot.DirSnapshot.records" href="#dirsnapshot.DirSnapshot.records">records</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dirsnapshot.SnapshotInfo" href="#dirsnapshot.SnapshotInfo">SnapshotInfo</a></code></h4>
<ul class="">
<li><code><a title="dirsnapshot.SnapshotInfo.datetime" href="#dirsnapshot.SnapshotInfo.datetime">datetime</a></code></li>
<li><code><a title="dirsnapshot.SnapshotInfo.description" href="#dirsnapshot.SnapshotInfo.description">description</a></code></li>
<li><code><a title="dirsnapshot.SnapshotInfo.directory" href="#dirsnapshot.SnapshotInfo.directory">directory</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dirsnapshot.SnapshotRecord" href="#dirsnapshot.SnapshotRecord">SnapshotRecord</a></code></h4>
<ul class="two-column">
<li><code><a title="dirsnapshot.SnapshotRecord.Path" href="#dirsnapshot.SnapshotRecord.Path">Path</a></code></li>
<li><code><a title="dirsnapshot.SnapshotRecord.asdict" href="#dirsnapshot.SnapshotRecord.asdict">asdict</a></code></li>
<li><code><a title="dirsnapshot.SnapshotRecord.gid" href="#dirsnapshot.SnapshotRecord.gid">gid</a></code></li>
<li><code><a title="dirsnapshot.SnapshotRecord.is_dir" href="#dirsnapshot.SnapshotRecord.is_dir">is_dir</a></code></li>
<li><code><a title="dirsnapshot.SnapshotRecord.is_file" href="#dirsnapshot.SnapshotRecord.is_file">is_file</a></code></li>
<li><code><a title="dirsnapshot.SnapshotRecord.mode" href="#dirsnapshot.SnapshotRecord.mode">mode</a></code></li>
<li><code><a title="dirsnapshot.SnapshotRecord.mtime" href="#dirsnapshot.SnapshotRecord.mtime">mtime</a></code></li>
<li><code><a title="dirsnapshot.SnapshotRecord.path" href="#dirsnapshot.SnapshotRecord.path">path</a></code></li>
<li><code><a title="dirsnapshot.SnapshotRecord.size" href="#dirsnapshot.SnapshotRecord.size">size</a></code></li>
<li><code><a title="dirsnapshot.SnapshotRecord.uid" href="#dirsnapshot.SnapshotRecord.uid">uid</a></code></li>
<li><code><a title="dirsnapshot.SnapshotRecord.user_data" href="#dirsnapshot.SnapshotRecord.user_data">user_data</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>